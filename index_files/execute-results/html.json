{
  "hash": "91799c438db848b83365a9d7c8dd71dc",
  "result": {
    "engine": "knitr",
    "markdown": "# Detección de cuentas \"Fake\" de Instagram\n\nDetectar cuentas no reales o \"fake\" en Instagram no es un trabajo fácil. Sin embargo, es posible construir un modelo que te diga la probabilidad de que una cuenta de Instagram sea real o no.\n\nPara este propósito, nos basaremos en un conjunto de datos que recopila una variedad de características que podrían servir como indicadores de la falsedad de una cuenta.\n\nMediante el análisis exploratorio de estos datos, nuestro objetivo es identificar patrones y tendencias que permitan diferenciar de manera efectiva entre cuentas auténticas y falsas en la plataforma.\n\n## Importación de las librerías y Dataset\n\nPrimero, antes de comenzar con el análisis exploratorio, importaremos todas las librerías necesarias para aplicar los diferentes datos, además de importar el Dataset train.csv.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'lubridate' was built under R version 4.3.3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.0     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(arules)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'arules' was built under R version 4.3.3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: Matrix\n\nAttaching package: 'Matrix'\n\nThe following objects are masked from 'package:tidyr':\n\n    expand, pack, unpack\n\n\nAttaching package: 'arules'\n\nThe following object is masked from 'package:dplyr':\n\n    recode\n\nThe following objects are masked from 'package:base':\n\n    abbreviate, write\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(arulesViz)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'arulesViz' was built under R version 4.3.3\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(readr)\nlibrary(ggplot2)\nlibrary(magrittr)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'magrittr'\n\nThe following object is masked from 'package:purrr':\n\n    set_names\n\nThe following object is masked from 'package:tidyr':\n\n    extract\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(fcaR)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'fcaR' was built under R version 4.3.3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'fcaR'\n\nThe following object is masked from 'package:Matrix':\n\n    %&%\n\nThe following object is masked from 'package:purrr':\n\n    as_vector\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(funModeling)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'funModeling' was built under R version 4.3.3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: Hmisc\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'Hmisc' was built under R version 4.3.3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'Hmisc'\n\nThe following objects are masked from 'package:dplyr':\n\n    src, summarize\n\nThe following objects are masked from 'package:base':\n\n    format.pval, units\n\nfunModeling v.1.9.5 :)\nExamples and tutorials at livebook.datascienceheroes.com\n / Now in Spanish: librovivodecienciadedatos.ai\n```\n\n\n:::\n\n```{.r .cell-code}\ntrain <- read_csv(\"train.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 576 Columns: 12\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (12): profile pic, nums/length username, fullname words, nums/length ful...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\nComo ya tenemos todo bien importado, comenzamos.\n\n## Análisis exploratorio de los datos\n\nPrimero, vamos a ver un resumen de la estructura de nuestra tabla y visualizar las primeras y últimas filas de nuestro dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(train)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 576\nColumns: 12\n$ `profile pic`          <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,…\n$ `nums/length username` <dbl> 0.27, 0.00, 0.10, 0.00, 0.00, 0.00, 0.00, 0.00,…\n$ `fullname words`       <dbl> 0, 2, 2, 1, 2, 4, 2, 2, 0, 2, 2, 2, 2, 2, 2, 3,…\n$ `nums/length fullname` <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ `name==username`       <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ `description length`   <dbl> 53, 44, 0, 82, 0, 81, 50, 0, 71, 40, 54, 54, 0,…\n$ `external URL`         <dbl> 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0,…\n$ private                <dbl> 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ `#posts`               <dbl> 32, 286, 13, 679, 6, 344, 16, 33, 72, 213, 648,…\n$ `#followers`           <dbl> 1000, 2740, 159, 414, 151, 669987, 122, 1078, 1…\n$ `#follows`             <dbl> 955, 533, 98, 651, 126, 150, 177, 76, 2713, 813…\n$ fake                   <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(train)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 12\n  `profile pic` `nums/length username` `fullname words` `nums/length fullname`\n          <dbl>                  <dbl>            <dbl>                  <dbl>\n1             1                   0.27                0                      0\n2             1                   0                   2                      0\n3             1                   0.1                 2                      0\n4             1                   0                   1                      0\n5             1                   0                   2                      0\n6             1                   0                   4                      0\n# ℹ 8 more variables: `name==username` <dbl>, `description length` <dbl>,\n#   `external URL` <dbl>, private <dbl>, `#posts` <dbl>, `#followers` <dbl>,\n#   `#follows` <dbl>, fake <dbl>\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntail(train)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 12\n  `profile pic` `nums/length username` `fullname words` `nums/length fullname`\n          <dbl>                  <dbl>            <dbl>                  <dbl>\n1             1                   0.2                 1                   0   \n2             1                   0.55                1                   0.44\n3             1                   0.38                1                   0.33\n4             1                   0.57                2                   0   \n5             1                   0.57                1                   0   \n6             1                   0.27                1                   0   \n# ℹ 8 more variables: `name==username` <dbl>, `description length` <dbl>,\n#   `external URL` <dbl>, private <dbl>, `#posts` <dbl>, `#followers` <dbl>,\n#   `#follows` <dbl>, fake <dbl>\n```\n\n\n:::\n:::\n\n\nEl data set tiene las siguientes columnas:\n\n-   **Profile pic:** nos indica si el la cuenta tiene imagen de perfil.\n\n-   **Nums/length username:** porcentaje de numeros que tiene el nombre de usuario\n\n-   **Fullname words:** el numero de palaras que tiene el nombre completo de la cuenta\n\n-   **Nums/length full name:** porcentaje de numeros que tiene el nombre comple\n\n-   **Name==username:** nos indica si el nombre completo es igual al usuario\n\n-   **Description length:** nos muestra el numero de caracteres que tiene la descripcion de la cuenta\n\n-   **ExternalURL:** nos muestra si tiene una URL externa o no.\n\n-   **Private:** nos dice si la privacidad de la cuenta es pública(0) o privada(1)\n\n-   **Posts:** nos indica el número de posts que tiene la cuenta\n\n-   **Followers:** nos dice el número de seguidores que tiene la cuenta\n\n-   **Follows:** nos indica el número de cuentas que sigue el usuario\n\n-   **Fake:** es la columna más importante, nos dice si la cuenta es falsa o no.\n\nUna vez puestos en contexto, podemos comenzar con el análisis exploratorio.\n\nLo primero que debemos hacer es ver el numero de variable que almacena el dataset así como el numero de datos del que disponemos, además del estado de los mismo, es decir, ver si hay muchos na, sin hay muchos únicos, etc; para así poder descartar fácilmente aquellas columnas que no aportan ninguna información.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nncol(train)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(train)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 576\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstatus(train)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                                 variable q_zeros    p_zeros q_na p_na q_inf\nprofile pic                   profile pic     172 0.29861111    0    0     0\nnums/length username nums/length username     299 0.51909722    0    0     0\nfullname words             fullname words      57 0.09895833    0    0     0\nnums/length fullname nums/length fullname     518 0.89930556    0    0     0\nname==username             name==username     556 0.96527778    0    0     0\ndescription length     description length     326 0.56597222    0    0     0\nexternal URL                 external URL     509 0.88368056    0    0     0\nprivate                           private     356 0.61805556    0    0     0\n#posts                             #posts     157 0.27256944    0    0     0\n#followers                     #followers      18 0.03125000    0    0     0\n#follows                         #follows      11 0.01909722    0    0     0\nfake                                 fake     288 0.50000000    0    0     0\n                     p_inf    type unique\nprofile pic              0 numeric      2\nnums/length username     0 numeric     54\nfullname words           0 numeric      9\nnums/length fullname     0 numeric     25\nname==username           0 numeric      2\ndescription length       0 numeric    104\nexternal URL             0 numeric      2\nprivate                  0 numeric      2\n#posts                   0 numeric    193\n#followers               0 numeric    372\n#follows                 0 numeric    400\nfake                     0 numeric      2\n```\n\n\n:::\n:::\n\n\nNinguna columna tiene datos NA, por lo que podemos decir que este dataset es completo.\n\nAdemás, podemos observar que la columna name==username tiene un 96% de porcentaje de 0s, lo cual nos puede dar algún indicio de que sea inservible. Sin embargo, lo dejaremos para ver que reglas nos salen con este atributo y decidiremos.\n\nPara saber en que datos nos estamos moviendo, me gustaría saber cual es la frecuencia de cuentas fake que tenemos. Para ellos vamos a utilizar el comando table.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(train$fake)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n  0   1 \n288 288 \n```\n\n\n:::\n:::\n\n\nComo puedes ver, la mitad de las cuentas en nuestro dataset son falsas. Así que ahora toca escarbar más profundo para entender qué las hace diferentes de las cuentas reales.\n\nSiguiendo el sentido común, normalmente las cuentas fake no suelen tener fotos de perfil, por lo que nuestro siguiente estudio se centrará en ver que ratio de cuentas fake no tienen foto de perfil, a ver si a priori tenemos razón.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumfotoPerfilFake <- train %>% filter(`profile pic` == 0 & fake == 1) %>% nrow()\nnumDatosFake <- train %>% filter(fake == 1) %>%  nrow()\nnumfotoPerfilFake/numDatosFake\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5902778\n```\n\n\n:::\n:::\n\n\nTeniamos cierta razón, de todas las cuentas fakes, casi un 60% de ellas no tienen foto de perfil, por lo que pienso que este dato es importante para la detección de dichas cuentas.\n\nOtro dato muy a tener en cuenta son los seguidores de una cuenta, ya que la mayoría de cuentas falsas no tienen muchos seguidores. Vamos a ver si es cierto esto.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmedfollowersFake <- train %>% filter(fake == 1) %>% select(`#followers`)\nmedfollowersFake <- mean(medfollowersFake$`#followers`)\n\nmedfollowersReal <- train %>% filter(fake == 0) %>% select(`#followers`)\nmedfollowersReal <- mean(medfollowersReal$`#followers`)\n\nmedfollowersFake\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 110.5868\n```\n\n\n:::\n\n```{.r .cell-code}\nmedfollowersReal\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 170503.9\n```\n\n\n:::\n:::\n\n\nLa diferencia de medias es bastante grande, mientras que la media de seguidores de las cuentas falsas son de 110.6 aproximadamente, la media de seguidores de las cuentas reales es de 170504. Esto nos afirma que una cuenta con un numero bajo de seguidores, tiene bastante probabilidad de ser una cuenta falsa, aunque no nos lo asegura al 100% ya que hay muchas cuentas reales con menos seguidores que la primera media.\n\nA continuación, vamos a comprobar que correlación tienen las cuentas fake con la longitud de las descripciones.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncor(train$fake, train$`description length`)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -0.4608246\n```\n\n\n:::\n:::\n\n\nComo podemos ver, un valor más alto en la variable fake tiende a estar asociado con una longitud más corta en la descripción del perfil en Instagram. Por lo tanto, podríamos inferir que las cuentas que tienen descripciones más cortas tienden a ser más propensas a ser falsas.\n\nHemos visto las relaciones entre algunas columnas de datos para saber un poco más que tipo de datos estamos manejando. Tras esto, vamos a visualizar todo lo que hemos visto en forma de gráficos, para poder ver las relaciones de los datos de una manera más simple y rápida.\n\n## Visualización de Datos\n\nA continuación, vamos a crear una variedad de grafos que nos van a ayudar a explorar y comunicar las relaciones entre las diferentes variables.\n\nPrimero visualizaremos la distribución de las variables numéricas como **profile_pics, nums/length username.**\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain %>% group_by(`profile pic`) %>% count() %>% \n  ggplot(aes(x= `profile pic`, y = n)) +  geom_bar(stat=\"identity\", fill=\"red\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain %>% filter(`nums/length username`!= 0) %>%  group_by(`nums/length username`) %>% count() %>% \n  ggplot(aes(x= `nums/length username`, y = n)) +  geom_bar(stat=\"identity\", fill=\"red\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\nAhora realizaremos un bloxplot para comparar la distribución de una variable numérica entre diferentes grupos. Por ejemplo, **followers** por **fake**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain %>% ggplot(aes(x=factor(fake), y=`#followers`)) + \n  geom_boxplot(fill=\"lightblue\", color=\"darkblue\") + \n  labs(title=\"Seguidores por Tipo de Cuenta\", x=\"Cuenta Fake\", y=\"Número de Seguidores\") + \n  scale_x_discrete(labels=c(\"0\" = \"Real\", \"1\" = \"Fake\")) + \n  facet_wrap(~ fake, scales = \"free\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\nAqui nos damos cuenta de que el numero de seguidores de una cuenta real es mucha mayor a la de las cuentas fake.\n\nA continuación, vamos a visualizar un scatter plot o diagrama de dispersión para explorar relaciones entre pares de variables numéricas, como **followers** vs **posts**. Como ambas variables tienen una gran variedad de datos distintos, vamos a agregar una línea de suavizado para capturar la tendencia general de los datos. Además, debido a la alta variabilidad y los valores extremos de las variables, voy a aplicar una transformación logarítmica para ayudar a visualizar mejor su relación.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain %>% ggplot(aes(x=log1p(`#followers`), y = log1p(`#posts` ))) + \n  geom_point(alpha=0.4) + \n  geom_smooth(method=\"loess\") + \n  labs(title=\"Seguidores vs Posts con Suavizado\", x=\"Número de Seguidores\", y=\"Número de Posts\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\nAhora vamos a comprarar distribuciones de variables numéricas entre diferentes grupos utilizando gráficos de densidad.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain %>% ggplot( aes(x=`description length`, fill=factor(fake))) + \n  geom_density(alpha=0.5) + \n  labs(title=\"Densidad de Longitud de Descripción por Tipo de Cuenta\", x=\"Longitud de Descripción\", fill=\"Cuenta Fake\") \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\nDe esta gráfica podemos sacar varias conclusiones:\n\n-   Las cuentas falsas tienen tendencia a tener descripciones más cortas\n\n-   Las cuentas no falsas tienen una variedad más amplia en la longitud de sus descripciones\n\n-   La densidad para las cuentas falsas es alta cuando la longitud de la descripción es corta, disminuyendo rápidamente a medida que aumenta la longitud.\n\n## Reglas de Asociación\n\n### Preparación\n\nAl usar el método a priori, debemos convertir todas aquelas variables continuas y numéricas en categóricas, es decir, en factores. En nuestro caso al ser todas numéricas, habrá que cambiar todo, pero lo haremos en una copia, no en la original.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Creamos la copia\ntrain_factor <- train\n\n# Foto de perfil\ntrain_factor$`profile pic` <- as.factor(train_factor$`profile pic`)\n\n# Nombre = Nombre Usuario\ntrain_factor$`name==username` <- as.factor(train_factor$`name==username`)\n\n# URL Externa\ntrain_factor$`external URL` <- as.factor(train_factor$`external URL`)\n\n# Privado\ntrain_factor$private <- as.factor(train_factor$private)\n\n# Fake\ntrain_factor$fake <- as.factor(train_factor$fake)\n\n# nums/length username\ntrain_factor$`nums/length username` <- ordered(cut(train_factor$`nums/length username`, \n                               breaks = c(-Inf, 0.1, 0.5, Inf), \n                               labels = c(\"Bajo\", \"Medio\", \"Alto\")))\n\n# nums/length fullname\ntrain_factor$`nums/length fullname` <- ordered(cut(train_factor$`nums/length fullname`, \n                               breaks = c(-Inf, 0.1, 0.5, Inf), \n                               labels = c(\"Bajo\", \"Medio\", \"Alto\")))\n\n# fullname words \ntrain_factor$`fullname words` <- ordered(cut(train_factor$`fullname words`, \n                         breaks = c(-Inf, 1, 4, Inf), \n                         labels = c(\"Corto\", \"Medio\", \"Largo\")))\n\n# description length\ntrain_factor$`description length` <- ordered(cut(train_factor$`description length` , \n                             breaks = c(-Inf, 50, 100, Inf), \n                             labels = c(\"Corto\", \"Medio\", \"Largo\")))\n# #posts\n# Utilizaremos cuantiles debido a que la distribución de los datos, como hemos visto, no es uniforme\nbreaks_posts <- unique(quantile(train_factor$`#posts`, probs = seq(0, 1, 0.25)))\n\ntrain_factor$`#posts` <- ordered(cut(train_factor$`#posts`, \n                breaks = breaks_posts, \n                include.lowest = TRUE, \n                labels = c(\"Bajo\", \"Medio\", \"Alto\")))\n\n# #followers \nbreaks_followers <- unique(quantile(train_factor$`#followers`, probs = seq(0, 1, 0.25)))\n                           \ntrain_factor$`#followers` <- cut(train_factor$`#followers`, \n                    breaks = breaks_followers, \n                    include.lowest = TRUE, \n                    labels = c(\"Bajo\", \"Medio-Bajo\", \"Medio-Alto\", \"Alto\"))\n\n#  #follows \nbreaks_follows <- unique(quantile(train_factor$`#follows`, probs = seq(0, 1, 0.25)))\n\ntrain_factor$`#follows` <- cut(train_factor$`#follows`, \n                  breaks = breaks_follows, \n                  include.lowest = TRUE, \n                  labels = c(\"Bajo\", \"Medio-Bajo\", \"Medio-Alto\", \"Alto\"))\n```\n:::\n\n\nUna vez preparado nuestras variables, convertimos el tipo de datos a transacciones para poder realizar a priori.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain_transactions <- as(train_factor, \"transactions\")\n```\n:::\n\n\n### Extracción de reglas por el método a priori\n\nVamos a realizar el método a priori para obtener las reglas de asociación, con un 15% de soporte mínimo y una confianza mínima del 80%.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain_rules <- apriori(train_transactions, parameter = list(supp = 0.15, conf = 0.8))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nApriori\n\nParameter specification:\n confidence minval smax arem  aval originalSupport maxtime support minlen\n        0.8    0.1    1 none FALSE            TRUE       5    0.15      1\n maxlen target  ext\n     10  rules TRUE\n\nAlgorithmic control:\n filter tree heap memopt load sort verbose\n    0.1 TRUE TRUE  FALSE TRUE    2    TRUE\n\nAbsolute minimum support count: 86 \n\nset item appearances ...[0 item(s)] done [0.00s].\nset transactions ...[33 item(s), 576 transaction(s)] done [0.00s].\nsorting and recoding items ... [25 item(s)] done [0.00s].\ncreating transaction tree ... done [0.00s].\nchecking subsets of size 1 2 3 4 5 6 7 8 done [0.00s].\nwriting ... [5333 rule(s)] done [0.00s].\ncreating S4 object  ... done [0.00s].\n```\n\n\n:::\n\n```{.r .cell-code}\n# Ordenamos por confianza\ntrain_rules <- sort(train_rules, by = \"confidence\")\n```\n:::\n\n\nHemos obtenido un total de 5333 reglas.\n\nPara conocer un poco más que reglas e itemset hemos sacado, vamos a visualizar los itemsets más frecuentes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbarplot(table(size(train_rules)),\n        xlab = \"Tamaño de itemset\", ylab = \"Frecuencia\",\n        main = \"Tamaños de itemsets en los itemsets frecuentes\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\nAntes de seguir analizando las diferentes reglas, vamos a eliminar las reglas que son redundantes, es decir, reglas que están incluidas en otras.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain_rules_pruned<- train_rules[which(!is.redundant(train_rules))]\n```\n:::\n\n\nA continuación eliminaremos aquella reglas con confianza == 1 ya que el objetivo de este análisis es descubrir relaciones no triviales o patrones inesperados, por lo que las verdades absolutas no nos interesan.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain_rules_selected <- subset(train_rules_pruned, subset = confidence < 1)\n```\n:::\n\n\nPara la obtención de relaciones no triviales y de las asociaciones más útiles, vamos a escoger aquellas reglas cuyo lift sea \\> 1 y ordenaremos por lift para obtener las más útiles.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain_rules_selected <- subset(train_rules_selected, subset = lift > 1)\n\ntrain_rules_selected <- sort(train_rules_selected, by = \"lift\")\n\ninspect(head(train_rules_selected, 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     lhs                             rhs             support confidence  coverage     lift count\n[1]  {profile pic=1,                                                                            \n      nums/length username=Bajo,                                                                \n      #followers=Alto}            => {fake=0}      0.2031250  0.9915254 0.2048611 1.983051   117\n[2]  {nums/length username=Bajo,                                                                \n      name==username=0,                                                                         \n      #followers=Alto}            => {fake=0}      0.2031250  0.9915254 0.2048611 1.983051   117\n[3]  {nums/length username=Bajo,                                                                \n      private=0,                                                                                \n      #posts=Alto}                => {fake=0}      0.1545139  0.9888889 0.1562500 1.977778    89\n[4]  {profile pic=0}              => {fake=1}      0.2951389  0.9883721 0.2986111 1.976744   170\n[5]  {profile pic=0,                                                                            \n      #followers=Bajo}            => {#posts=Bajo} 0.1666667  0.9896907 0.1684028 1.972532    96\n[6]  {fullname words=Corto,                                                                     \n      #followers=Bajo}            => {fake=1}      0.2135417  0.9840000 0.2170139 1.968000   123\n[7]  {nums/length username=Bajo,                                                                \n      #posts=Alto}                => {fake=0}      0.2118056  0.9838710 0.2152778 1.967742   122\n[8]  {nums/length username=Bajo,                                                                \n      #followers=Alto}            => {fake=0}      0.2031250  0.9831933 0.2065972 1.966387   117\n[9]  {private=0,                                                                                \n      #posts=Alto}                => {fake=0}      0.1684028  0.9797980 0.1718750 1.959596    97\n[10] {#posts=Alto,                                                                              \n      #followers=Alto}            => {fake=0}      0.1631944  0.9791667 0.1666667 1.958333    94\n```\n\n\n:::\n:::\n\n\nComo podemos observar, de estas 10 reglas más útiles, las que verdaderamente nos importan son:\n\n-   profile pic = 0 -\\> fake = 1\n\n-   fullname words = Corto, #followers = Bajo -\\> fake = 1\n\nEs decir, lo que nos importa verdaderamente son aquellas reglas cuya parte derecha sea fake = 1, por lo que vamos a filtrarlo para ver que obtenemos.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain_rules_fake  <- subset(train_rules_selected, train_rules_selected@rhs %in% \"fake=1\")\n\ninspect(head(train_rules_fake, 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     lhs                              rhs        support confidence  coverage     lift count\n[1]  {profile pic=0}               => {fake=1} 0.2951389  0.9883721 0.2986111 1.976744   170\n[2]  {fullname words=Corto,                                                                 \n      #followers=Bajo}             => {fake=1} 0.2135417  0.9840000 0.2170139 1.968000   123\n[3]  {nums/length username=Medio,                                                           \n      fullname words=Corto,                                                                 \n      nums/length fullname=Bajo,                                                            \n      #posts=Bajo}                 => {fake=1} 0.1718750  0.9705882 0.1770833 1.941176    99\n[4]  {fullname words=Corto,                                                                 \n      nums/length fullname=Bajo,                                                            \n      description length=Corto,                                                             \n      private=0,                                                                            \n      #posts=Bajo}                 => {fake=1} 0.1718750  0.9705882 0.1770833 1.941176    99\n[5]  {nums/length username=Medio,                                                           \n      fullname words=Corto,                                                                 \n      #posts=Bajo}                 => {fake=1} 0.2274306  0.9703704 0.2343750 1.940741   131\n[6]  {fullname words=Corto,                                                                 \n      description length=Corto,                                                             \n      private=0,                                                                            \n      #posts=Bajo}                 => {fake=1} 0.2100694  0.9680000 0.2170139 1.936000   121\n[7]  {#followers=Bajo}             => {fake=1} 0.2447917  0.9657534 0.2534722 1.931507   141\n[8]  {fullname words=Corto,                                                                 \n      #posts=Bajo,                                                                          \n      #follows=Bajo}               => {fake=1} 0.1770833  0.9622642 0.1840278 1.924528   102\n[9]  {fullname words=Corto,                                                                 \n      nums/length fullname=Bajo,                                                            \n      private=0,                                                                            \n      #posts=Bajo}                 => {fake=1} 0.1736111  0.9615385 0.1805556 1.923077   100\n[10] {fullname words=Corto,                                                                 \n      private=0,                                                                            \n      #posts=Bajo}                 => {fake=1} 0.2118056  0.9606299 0.2204861 1.921260   122\n```\n\n\n:::\n:::\n\n\nVamos a visualizar gráficamente estas reglas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(train_rules_fake, method = \"graph\", control = list(type = \"items\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Unknown control parameters: type\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAvailable control parameters (with default values):\nlayout\t =  stress\ncircular\t =  FALSE\nggraphdots\t =  NULL\nedges\t =  <environment>\nnodes\t =  <environment>\nnodetext\t =  <environment>\ncolors\t =  c(\"#EE0000FF\", \"#EEEEEEFF\")\nengine\t =  ggplot2\nmax\t =  100\nverbose\t =  FALSE\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\n### Conclusión y Recomendaciones\n\nCon todos estos datos, las recomendaciones que podemos dar para reconocer fácilmente las cuentas fakes son:\n\n-   Monitorear aquellas cuentas sin foto de perfil, ya que según hemos comprobado tienen una confianzadel 98% y tienen 1,98 más probabilidad de ser fake que las demás\n\n-   Hacer incapié en aquellas cuentas con nombre completo corto, ya que pertenece a la mayor parte reglas, realizando un análisis más profundo de otras caracteristicas como la descripcion, numero de posts, su privacidad, entre otros.\n\n## FCA - Formal Concept Analysis\n\nEl Análisis de Conceptos Formales nos puede ayudar a descubrir patrones que podrían ser útiles para comprender mejor las características de estas cuentas y para desarrollar estrategias de detección más efectivas.\n\n### Preparación\n\nAl haber factorizado los datos, vamos a trabajar sobre los mismos, ya que al hacer el proceso de scaling nos van a salir mejores resultados con categorías discretas que con datos númericos diferentes.\n\n#### Contexto Formal\n\nPrimero, como ya tenemos los datos categorizados, crearemos el contexto formal.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncontexto_train <- FormalContext$new(train_factor)\ncontexto_train\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFormalContext with 576 objects and 12 attributes.\n# A tibble: 576 × 12\n   `profile pic` `nums/length username` `fullname words` `nums/length fullname`\n   <fct>         <ord>                  <ord>            <ord>                 \n 1 1             Medio                  Corto            Bajo                  \n 2 1             Bajo                   Medio            Bajo                  \n 3 1             Bajo                   Medio            Bajo                  \n 4 1             Bajo                   Corto            Bajo                  \n 5 1             Bajo                   Medio            Bajo                  \n 6 1             Bajo                   Medio            Bajo                  \n 7 1             Bajo                   Medio            Bajo                  \n 8 1             Bajo                   Medio            Bajo                  \n 9 1             Bajo                   Corto            Bajo                  \n10 1             Bajo                   Medio            Bajo                  \n# ℹ 566 more rows\n# ℹ 8 more variables: `name==username` <fct>, `description length` <ord>,\n#   `external URL` <fct>, private <fct>, `#posts` <ord>, `#followers` <fct>,\n#   `#follows` <fct>, fake <fct>\n```\n\n\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}